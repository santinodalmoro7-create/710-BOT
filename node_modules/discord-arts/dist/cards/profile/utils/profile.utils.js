"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBadges = getBadges;
exports.genBase = genBase;
exports.genFrame = genFrame;
exports.genBorder = genBorder;
exports.genTextAndAvatar = genTextAndAvatar;
exports.genAvatarFrame = genAvatarFrame;
exports.genXpBar = genXpBar;
exports.genBadges = genBadges;
exports.genBotVerifBadge = genBotVerifBadge;
exports.addShadow = addShadow;
const { createCanvas, loadImage } = require('@napi-rs/canvas');
const profile_image_files_json_1 = require("../../../../public/profile-image.files.json");
const strings_utils_1 = require("../../../core/services/strings.utils");
const validations_utils_1 = require("../../../core/services/validations.utils");
const error_utils_1 = require("../../../core/errors/error.utils");
const assets_1 = require("../../../constants/assets");
const alphaValue = 0.4;
const clydeID = '1081004946872352958';
function getBadges(data, options) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const { assets } = data;
        const badges = (assets === null || assets === void 0 ? void 0 : assets.badges) || [];
        const canvasBadges = [];
        for (const badge of badges.reverse()) {
            const { name, icon } = badge;
            const canvas = yield loadImage(icon).catch(() => { });
            if (!canvas) {
                throw new error_utils_1.DiscordArtsError(`Could not load badge: (${name})\nIf you think it is not a network problem, please report it in our discord: https://discord.gg/csedxqGQKP`);
            }
            canvasBadges.push({ canvas, x: 0, y: 15, w: 60 });
        }
        if ((_a = options === null || options === void 0 ? void 0 : options.customBadges) === null || _a === void 0 ? void 0 : _a.length) {
            if (options === null || options === void 0 ? void 0 : options.overwriteBadges) {
                canvasBadges.splice(0, badges.length);
            }
            for (let i = 0; i < options.customBadges.length; i++) {
                const canvas = yield loadImage((0, validations_utils_1.parsePng)(options.customBadges[i])).catch(() => { });
                if (!canvas) {
                    const truncatedBadge = (0, strings_utils_1.truncateText)(options.customBadges[i], 30);
                    throw new error_utils_1.DiscordArtsError(`Could not load custom badge: (${truncatedBadge}), make sure that the image exists.`);
                }
                canvasBadges.push({ canvas, x: 10, y: 22, w: 46 });
            }
        }
        return canvasBadges;
    });
}
function genBase(options, avatarData, bannerData) {
    return __awaiter(this, void 0, void 0, function* () {
        const canvas = createCanvas(885, 303);
        const ctx = canvas.getContext('2d');
        let isBannerLoaded = true;
        let cardBackground = yield loadImage((options === null || options === void 0 ? void 0 : options.customBackground)
            ? (0, validations_utils_1.parseImg)(options.customBackground)
            : bannerData !== null && bannerData !== void 0 ? bannerData : avatarData).catch(() => { });
        if (!cardBackground) {
            cardBackground = yield loadImage(avatarData).catch(() => { });
            isBannerLoaded = false;
        }
        const condAvatar = (options === null || options === void 0 ? void 0 : options.customBackground)
            ? true
            : !isBannerLoaded
                ? false
                : bannerData !== null;
        const wX = condAvatar ? 885 : 900;
        const wY = condAvatar ? 303 : wX;
        const cY = condAvatar ? 0 : -345;
        ctx.fillStyle = '#18191c';
        ctx.beginPath();
        ctx.fillRect(0, 0, 885, 303);
        ctx.fill();
        ctx.filter =
            ((options === null || options === void 0 ? void 0 : options.moreBackgroundBlur)
                ? 'blur(9px)'
                : (options === null || options === void 0 ? void 0 : options.disableBackgroundBlur)
                    ? 'blur(0px)'
                    : 'blur(3px)') +
                ((options === null || options === void 0 ? void 0 : options.backgroundBrightness)
                    ? ` brightness(${options.backgroundBrightness + 100}%)`
                    : '');
        ctx.drawImage(cardBackground, 0, cY, wX, wY);
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#2a2d33';
        ctx.beginPath();
        ctx.fillRect(0, 0, 885, 303);
        ctx.fill();
        return canvas;
    });
}
function createFrame({ width = 300, height = 300, borderRadius = 20, frameThickness = 10, frameColor = '#000000' }) {
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');
    ctx.beginPath();
    ctx.roundRect(0, 0, width, height, borderRadius);
    ctx.fillStyle = frameColor;
    ctx.fill();
    ctx.beginPath();
    ctx.roundRect(frameThickness, frameThickness, width - (frameThickness * 2), height - (frameThickness * 2), borderRadius > frameThickness ? borderRadius - frameThickness : 0);
    ctx.fillStyle = '#ffffff';
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fill();
    return canvas;
}
function genFrame(badges, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const canvas = createCanvas(885, 303);
        const ctx = canvas.getContext('2d');
        const cardFrame = yield loadImage(Buffer.from(profile_image_files_json_1.otherImgs.frame, 'base64'));
        ctx.globalCompositeOperation = 'source-out';
        ctx.globalAlpha = 0.5;
        ctx.drawImage(cardFrame, 0, 0, 885, 303);
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = alphaValue;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.roundRect(696, 248, 165, 33, [12]);
        ctx.fill();
        ctx.globalAlpha = 1;
        const badgesLength = badges.length;
        if ((options === null || options === void 0 ? void 0 : options.badgesFrame) && badgesLength > 0 && !(options === null || options === void 0 ? void 0 : options.removeBadges)) {
            ctx.fillStyle = '#000';
            ctx.globalAlpha = alphaValue;
            ctx.beginPath();
            ctx.roundRect(857 - badgesLength * 59, 15, 59 * badgesLength + 8, 61, [17]);
            ctx.fill();
        }
        return canvas;
    });
}
function genBorder(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const canvas = createCanvas(885, 303);
        const ctx = canvas.getContext('2d');
        const borderColors = [];
        if (typeof options.borderColor == 'string')
            borderColors.push(options.borderColor);
        else
            borderColors.push(...options.borderColor);
        if (borderColors.length > 20)
            throw new error_utils_1.DiscordArtsError(`Invalid borderColor length (${borderColors.length}) must be a maximum of 20 colors`);
        const gradX = options.borderAllign == 'vertical' ? 0 : 885;
        const gradY = options.borderAllign == 'vertical' ? 303 : 0;
        const grd = ctx.createLinearGradient(0, 0, gradX, gradY);
        for (let i = 0; i < borderColors.length; i++) {
            const stop = i / (borderColors.length - 1);
            grd.addColorStop(stop, (0, validations_utils_1.parseHex)(borderColors[i]));
        }
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.fillRect(0, 0, 885, 303);
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.roundRect(9, 9, 867, 285, [25]);
        ctx.fill();
        return canvas;
    });
}
function genTextAndAvatar(data, options, avatarData) {
    return __awaiter(this, void 0, void 0, function* () {
        const { basicInfo } = data;
        const { globalName, username: rawUsername, discriminator, bot, createdTimestamp, id, } = basicInfo;
        const isClyde = id === clydeID;
        const pixelLength = bot ? 470 : 555;
        let canvas = createCanvas(885, 303);
        const ctx = canvas.getContext('2d');
        const fixedUsername = (options === null || options === void 0 ? void 0 : options.customUsername) || globalName || rawUsername;
        const font = (options === null || options === void 0 ? void 0 : options.customFont) || ((options === null || options === void 0 ? void 0 : options.font) ? assets_1.FONTS[options.font] : assets_1.FONTS.HELVETICA);
        const boldFont = typeof font === 'object' ? font.bold : font;
        const regularFont = typeof font === 'object' ? font.regular : font;
        const isBold = boldFont ? true : false;
        const { username, newSize } = (0, strings_utils_1.parseUsername)(fixedUsername, ctx, boldFont, '80', pixelLength, isBold);
        if ((options === null || options === void 0 ? void 0 : options.customSubtitle) && !options.rankData) {
            ctx.globalAlpha = alphaValue;
            ctx.fillStyle = '#2a2d33';
            ctx.beginPath();
            ctx.roundRect(304, 248, 380, 33, [12]);
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.font = `23px ${regularFont}`;
            ctx.textAlign = 'left';
            ctx.fillStyle = (options === null || options === void 0 ? void 0 : options.color) ? options.color : '#dadada';
            ctx.fillText(`${options === null || options === void 0 ? void 0 : options.customSubtitle}`, 314, 273);
        }
        const createdDateString = (0, strings_utils_1.getDateOrString)(options === null || options === void 0 ? void 0 : options.customDate, createdTimestamp, options === null || options === void 0 ? void 0 : options.localDateType);
        if (isClyde && !(options === null || options === void 0 ? void 0 : options.customTag)) {
            options.customTag = '@clyde';
        }
        const tag = (options === null || options === void 0 ? void 0 : options.customTag)
            ? (0, validations_utils_1.isString)(options.customTag, 'customTag')
            : !discriminator
                ? `@${rawUsername}`
                : `#${discriminator}`;
        ctx.font = `bold ${newSize}px ${regularFont}`;
        ctx.textAlign = 'left';
        ctx.fillStyle = (options === null || options === void 0 ? void 0 : options.usernameColor)
            ? (0, validations_utils_1.parseHex)(options.usernameColor)
            : '#FFFFFF';
        ctx.fillText(username, 300, 155);
        if (!(options === null || options === void 0 ? void 0 : options.rankData)) {
            ctx.font = `60px ${regularFont}`;
            ctx.fillStyle = (options === null || options === void 0 ? void 0 : options.tagColor) ? (0, validations_utils_1.parseHex)(options.tagColor) : '#dadada';
            ctx.fillText(tag, 300, 215);
        }
        ctx.font = `23px ${regularFont}`;
        ctx.textAlign = 'center';
        ctx.fillStyle = '#dadada';
        ctx.fillText(createdDateString, 775, 273);
        const cardAvatar = yield loadImage(avatarData);
        const roundValue = (options === null || options === void 0 ? void 0 : options.squareAvatar) ? 30 : 225;
        ctx.beginPath();
        ctx.roundRect(47, 39, 225, 225, [roundValue]);
        ctx.clip();
        ctx.fillStyle = '#292b2f';
        ctx.beginPath();
        ctx.roundRect(47, 39, 225, 225, [roundValue]);
        ctx.fill();
        ctx.drawImage(cardAvatar, 47, 39, 225, 225);
        ctx.closePath();
        if (options === null || options === void 0 ? void 0 : options.presenceStatus) {
            canvas = yield genStatus(canvas, options);
        }
        return canvas;
    });
}
function genAvatarFrame(data, options) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        let canvas = createCanvas(885, 303);
        const ctx = canvas.getContext('2d');
        const frameUrl = (_a = data === null || data === void 0 ? void 0 : data.decoration) === null || _a === void 0 ? void 0 : _a.avatarFrame;
        const avatarFrame = yield loadImage(frameUrl);
        ctx.drawImage(avatarFrame, 25, 18, 269, 269);
        if (options === null || options === void 0 ? void 0 : options.presenceStatus) {
            canvas = yield cutAvatarStatus(canvas, options);
        }
        return canvas;
    });
}
function cutAvatarStatus(canvasToEdit, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const canvas = createCanvas(885, 303);
        const ctx = canvas.getContext('2d');
        const cX = options.presenceStatus == 'phone' ? 224.5 : 212;
        const cY = options.presenceStatus == 'phone' ? 202 : 204;
        ctx.drawImage(canvasToEdit, 0, 0);
        ctx.globalCompositeOperation = 'destination-out';
        if (options.presenceStatus == 'phone')
            ctx.roundRect(cX - 8, cY - 8, 57, 78, [10]);
        else
            ctx.roundRect(212, 204, 62, 62, [62]);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        return canvas;
    });
}
function genStatus(canvasToEdit, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let canvas = createCanvas(885, 303);
        const ctx = canvas.getContext('2d');
        const validStatus = [
            'idle',
            'dnd',
            'online',
            'invisible',
            'offline',
            'streaming',
            'phone',
        ];
        if (!validStatus.includes(options.presenceStatus))
            throw new error_utils_1.DiscordArtsError(`Invalid presenceStatus ('${options.presenceStatus}') must be 'online' | 'idle' | 'offline' | 'dnd' | 'invisible' | 'streaming' | 'phone'`);
        const statusString = options.presenceStatus == 'offline' ? 'invisible' : options.presenceStatus;
        const status = yield loadImage(Buffer.from(profile_image_files_json_1.statusImgs[statusString], 'base64'));
        const cX = options.presenceStatus == 'phone' ? 224.5 : 212;
        const cY = options.presenceStatus == 'phone' ? 202 : 204;
        ctx.drawImage(canvasToEdit, 0, 0);
        ctx.globalCompositeOperation = 'destination-out';
        if (options.presenceStatus == 'phone')
            ctx.roundRect(cX - 8, cY - 8, 57, 78, [10]);
        else
            ctx.roundRect(212, 204, 62, 62, [62]);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(status, cX, cY);
        return canvas;
    });
}
function genBadges(badges) {
    return __awaiter(this, void 0, void 0, function* () {
        const canvas = createCanvas(885, 303);
        const ctx = canvas.getContext('2d');
        let x = 800;
        badges.forEach((badge) => __awaiter(this, void 0, void 0, function* () {
            const { canvas, x: bX, y, w } = badge;
            ctx.drawImage(canvas, x + bX, y, w, w);
            x -= 59;
        }));
        return canvas;
    });
}
function genBotVerifBadge(data, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { basicInfo } = data;
        const { globalName, username: rawUsername, bot, id, } = basicInfo;
        const canvas = createCanvas(885, 303);
        const ctx = canvas.getContext('2d');
        const isClyde = id === clydeID;
        const fixedUsername = isClyde ? globalName : (options === null || options === void 0 ? void 0 : options.customUsername) || globalName || rawUsername;
        const font = (options === null || options === void 0 ? void 0 : options.customFont) || ((options === null || options === void 0 ? void 0 : options.font) ? assets_1.FONTS[options.font] : assets_1.FONTS.HELVETICA);
        const boldFont = typeof font === 'object' ? font.bold : font;
        const isBold = boldFont ? true : false;
        const pixelLength = bot ? 470 : 555;
        const { textLength } = (0, strings_utils_1.parseUsername)(fixedUsername, ctx, boldFont, '80', pixelLength, isBold);
        const badgeName = isClyde
            ? 'botAI'
            : (basicInfo === null || basicInfo === void 0 ? void 0 : basicInfo.verified)
                ? 'botVerif'
                : 'botNoVerif';
        const botBadgeBase64 = profile_image_files_json_1.otherImgs[badgeName];
        const botBagde = yield loadImage(Buffer.from(botBadgeBase64, 'base64'));
        ctx.drawImage(botBagde, textLength + 310, 110);
        return canvas;
    });
}
function genXpBar(options) {
    const { currentXp, requiredXp, level, rank, barColor, levelColor, autoColorRank, } = options.rankData;
    if (isNaN(currentXp) || isNaN(requiredXp) || isNaN(level)) {
        throw new error_utils_1.DiscordArtsError('rankData options requires: currentXp, requiredXp and level properties');
    }
    const canvas = createCanvas(885, 303);
    const ctx = canvas.getContext('2d');
    const mY = 8;
    ctx.fillStyle = '#000';
    ctx.globalAlpha = alphaValue;
    ctx.beginPath();
    ctx.roundRect(304, 248, 380, 33, [12]);
    ctx.fill();
    ctx.globalAlpha = 1;
    const rankString = !isNaN(rank)
        ? `RANK #${(0, strings_utils_1.abbreviateNumber)((0, validations_utils_1.isNumber)(rank, 'rankData:rank'))}`
        : '';
    const lvlString = !isNaN(level)
        ? `Lvl ${(0, strings_utils_1.abbreviateNumber)((0, validations_utils_1.isNumber)(level, 'rankData:level'))}`
        : '';
    const font = (options === null || options === void 0 ? void 0 : options.customFont) || ((options === null || options === void 0 ? void 0 : options.font) ? assets_1.FONTS[options.font] : assets_1.FONTS.HELVETICA);
    const boldFont = typeof font === 'object' ? font.bold : font;
    const regularFont = typeof font === 'object' ? font.regular : font;
    ctx.font = `21px ${regularFont}`;
    ctx.textAlign = 'left';
    ctx.fillStyle = '#dadada';
    ctx.fillText(`${(0, strings_utils_1.abbreviateNumber)(currentXp)} / ${(0, strings_utils_1.abbreviateNumber)(requiredXp)} XP`, 314, 273);
    const rankColors = {
        gold: '#F1C40F',
        silver: '#a1a4c9',
        bronze: '#AD8A56',
        current: '#dadada',
    };
    const rankMapping = {
        'RANK #1': rankColors.gold,
        'RANK #2': rankColors.silver,
        'RANK #3': rankColors.bronze,
    };
    if (autoColorRank && rankMapping.hasOwnProperty(rankString)) {
        rankColors.current = rankMapping[rankString];
    }
    ctx.font = `bold 21px ${boldFont}`;
    ctx.textAlign = 'right';
    ctx.fillStyle = rankColors.current;
    ctx.fillText(`${rankString}`, 674 - ctx.measureText(lvlString).width - 10, 273);
    ctx.font = `bold 21px ${boldFont}`;
    ctx.textAlign = 'right';
    ctx.fillStyle = levelColor ? (0, validations_utils_1.parseHex)(levelColor) : '#dadada';
    ctx.fillText(`${lvlString}`, 674, 273);
    ctx.globalAlpha = alphaValue;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.roundRect(304, 187 - mY, 557, 36, [14]);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.roundRect(304, 187 - mY, 557, 36, [14]);
    ctx.clip();
    const barColors = [];
    if (typeof barColor == 'string')
        barColors.push(barColor);
    else
        barColors.push(...barColor);
    if (barColors.length > 20)
        throw new error_utils_1.DiscordArtsError(`Invalid barColor length (${barColors.length}) must be a maximum of 20 colors`);
    const barWidth = Math.round((currentXp * 556) / requiredXp);
    const grd = ctx.createLinearGradient(304, 197, 860, 197);
    for (let i = 0; i < barColors.length; i++) {
        const stop = i / (barColors.length - 1);
        grd.addColorStop(stop, (0, validations_utils_1.parseHex)(barColors[i]));
    }
    ctx.fillStyle = barColor ? grd : '#fff';
    ctx.beginPath();
    ctx.roundRect(304, 187 - mY, barWidth, 36, [
        14,
    ]);
    ctx.fill();
    return canvas;
}
function addShadow(canvasToEdit) {
    const canvas = createCanvas(885, 303);
    const ctx = canvas.getContext('2d');
    ctx.filter = 'drop-shadow(0px 4px 4px #000)';
    ctx.globalAlpha = alphaValue;
    ctx.drawImage(canvasToEdit, 0, 0);
    return canvas;
}
