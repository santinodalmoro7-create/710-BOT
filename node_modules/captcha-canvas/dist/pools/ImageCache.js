"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageCache = void 0;
const skia_canvas_1 = require("skia-canvas");
const errors_1 = require("../errors");
/**
 * Image Cache implementation for caching loaded skia-canvas Image objects.
 *
 * This cache stores loaded Image objects with path/URL as keys to eliminate
 * redundant I/O operations when the same background images are used repeatedly.
 * Uses LRU eviction with configurable size limits and TTL (time-to-live).
 *
 * @example Basic usage
 * ```typescript
 * const cache = new ImageCache({ maxCacheSize: 50, cacheTTL: 3600000 });
 *
 * // First load - cache miss, loads from disk/URL
 * const image1 = await cache.get('./background.jpg');
 *
 * // Second load - cache hit, returns cached image
 * const image2 = await cache.get('./background.jpg');
 * ```
 *
 * @example With custom configuration
 * ```typescript
 * const cache = new ImageCache({
 *   maxCacheSize: 100,
 *   cacheTTL: 1800000, // 30 minutes
 *   debug: true
 * });
 * ```
 */
class ImageCache {
    /**
     * Creates a new Image Cache instance.
     *
     * @param config - Cache configuration options
     */
    constructor(config = {}) {
        var _a, _b, _c;
        this.cache = new Map();
        this.maxCacheSize = (_a = config.maxCacheSize) !== null && _a !== void 0 ? _a : 50;
        this.cacheTTL = (_b = config.cacheTTL) !== null && _b !== void 0 ? _b : 3600000; // 1 hour default
        this.debug = (_c = config.debug) !== null && _c !== void 0 ? _c : false;
        this.stats = {
            size: 0,
            hits: 0,
            misses: 0,
            totalLoaded: 0,
            ttlEvictions: 0,
            sizeEvictions: 0
        };
        if (this.debug) {
            console.log(`ImageCache initialized: maxSize=${this.maxCacheSize}, TTL=${this.cacheTTL}ms`);
        }
    }
    /**
     * Normalizes cache keys for consistent lookup.
     *
     * @param source - Image source (path, URL, or Buffer)
     * @returns Normalized cache key
     */
    normalizeKey(source) {
        if (Buffer.isBuffer(source)) {
            // For Buffers, create a hash-based key
            // Using a simple approach - in production, you might want to use crypto.createHash
            return `buffer:${source.length}:${source.subarray(0, 16).toString('hex')}`;
        }
        // For strings (paths/URLs), normalize path separators and trim
        return source.toString().replace(/\\/g, '/').trim();
    }
    /**
     * Checks if a cache entry has expired based on TTL.
     *
     * @param entry - Cache entry to check
     * @returns True if entry has expired
     */
    isExpired(entry) {
        return Date.now() - entry.loadedAt > this.cacheTTL;
    }
    /**
     * Removes expired entries from the cache.
     */
    cleanupExpired() {
        const now = Date.now();
        const expiredKeys = [];
        for (const [key, entry] of this.cache.entries()) {
            if (now - entry.loadedAt > this.cacheTTL) {
                expiredKeys.push(key);
            }
        }
        for (const key of expiredKeys) {
            this.cache.delete(key);
            this.stats.size--;
            this.stats.ttlEvictions++;
            if (this.debug) {
                console.log(`Expired image evicted from cache: ${key}`);
            }
        }
    }
    /**
     * Performs LRU eviction if cache exceeds size limit.
     */
    evictLRU() {
        while (this.cache.size >= this.maxCacheSize) {
            // Find least recently used entry
            let lruKey = null;
            let lruTime = Date.now();
            for (const [key, entry] of this.cache.entries()) {
                if (entry.lastAccessed < lruTime) {
                    lruTime = entry.lastAccessed;
                    lruKey = key;
                }
            }
            if (lruKey) {
                this.cache.delete(lruKey);
                this.stats.size--;
                this.stats.sizeEvictions++;
                if (this.debug) {
                    console.log(`LRU evicted from cache: ${lruKey}`);
                }
            }
            else {
                break; // Safety break
            }
        }
    }
    /**
     * Loads an image from the specified source.
     *
     * @param source - Image source (file path, URL, or Buffer)
     * @returns Promise that resolves to loaded Image object
     */
    async loadImageFromSource(source) {
        try {
            const image = await (0, skia_canvas_1.loadImage)(source);
            this.stats.totalLoaded++;
            if (this.debug) {
                const sourceStr = Buffer.isBuffer(source) ? `Buffer(${source.length} bytes)` : source.toString();
                console.log(`Image loaded from source: ${sourceStr}`);
            }
            return image;
        }
        catch (error) {
            const sourceStr = Buffer.isBuffer(source) ? `Buffer(${source.length} bytes)` : source.toString();
            throw new errors_1.CaptchaGenerationError(`Failed to load image: ${(error === null || error === void 0 ? void 0 : error.message) || 'unknown error'}`, {
                param: 'image_source',
                actual: sourceStr,
                suggestion: 'Verify file path/URL exists and is a valid image format'
            });
        }
    }
    /**
     * Gets an image from cache or loads it if not cached.
     *
     * @param source - Image source as file path, URL, or Buffer
     * @returns Promise that resolves to the Image object
     *
     * @example Loading from file path
     * ```typescript
     * const image = await cache.get('./assets/background.jpg');
     * ```
     *
     * @example Loading from URL
     * ```typescript
     * const image = await cache.get('https://example.com/background.png');
     * ```
     *
     * @example Loading from Buffer
     * ```typescript
     * const imageBuffer = fs.readFileSync('./background.jpg');
     * const image = await cache.get(imageBuffer);
     * ```
     */
    async get(source) {
        const key = this.normalizeKey(source);
        // Clean up expired entries periodically
        this.cleanupExpired();
        // Check if image is in cache and not expired
        const cached = this.cache.get(key);
        if (cached && !this.isExpired(cached)) {
            // Cache hit
            cached.lastAccessed = Date.now();
            cached.accessCount++;
            this.stats.hits++;
            if (this.debug) {
                console.log(`Cache hit: ${key} (hits: ${this.stats.hits})`);
            }
            return cached.image;
        }
        // Cache miss - load image
        this.stats.misses++;
        if (this.debug) {
            console.log(`Cache miss: ${key} (misses: ${this.stats.misses})`);
        }
        const image = await this.loadImageFromSource(source);
        // Store in cache
        this.set(key, image, source);
        return image;
    }
    /**
     * Stores an image in the cache.
     *
     * @param key - Cache key (normalized)
     * @param image - Image object to cache
     * @param originalSource - Original source for debugging
     */
    set(key, image, originalSource) {
        // Remove existing entry if present
        if (this.cache.has(key)) {
            this.cache.delete(key);
            this.stats.size--;
        }
        // Perform LRU eviction if needed
        this.evictLRU();
        // Add new entry
        const entry = {
            image,
            source: Buffer.isBuffer(originalSource) ? `Buffer(${originalSource.length})` : originalSource.toString(),
            loadedAt: Date.now(),
            lastAccessed: Date.now(),
            accessCount: 1
        };
        this.cache.set(key, entry);
        this.stats.size++;
        if (this.debug) {
            console.log(`Image cached: ${key} (cache size: ${this.stats.size})`);
        }
    }
    /**
     * Manually sets an image in the cache.
     *
     * @param source - Image source identifier
     * @param image - Pre-loaded Image object
     *
     * @example Pre-loading images
     * ```typescript
     * const image = await loadImage('./background.jpg');
     * cache.setImage('./background.jpg', image);
     * ```
     */
    setImage(source, image) {
        const key = this.normalizeKey(source);
        this.set(key, image, source);
    }
    /**
     * Checks if an image is cached and not expired.
     *
     * @param source - Image source to check
     * @returns True if image is cached and valid
     *
     * @example
     * ```typescript
     * if (cache.has('./background.jpg')) {
     *   console.log('Image is cached');
     * }
     * ```
     */
    has(source) {
        const key = this.normalizeKey(source);
        const cached = this.cache.get(key);
        return cached !== undefined && !this.isExpired(cached);
    }
    /**
     * Removes an image from the cache.
     *
     * @param source - Image source to remove
     * @returns True if image was removed, false if not found
     *
     * @example
     * ```typescript
     * const removed = cache.delete('./old-background.jpg');
     * console.log(removed ? 'Removed' : 'Not found');
     * ```
     */
    delete(source) {
        const key = this.normalizeKey(source);
        const existed = this.cache.delete(key);
        if (existed) {
            this.stats.size--;
            if (this.debug) {
                console.log(`Image removed from cache: ${key}`);
            }
        }
        return existed;
    }
    /**
     * Clears all cached images.
     *
     * @example
     * ```typescript
     * cache.clear();
     * console.log('Cache cleared');
     * ```
     */
    clear() {
        const previousSize = this.cache.size;
        this.cache.clear();
        this.stats.size = 0;
        if (this.debug) {
            console.log(`Cache cleared: removed ${previousSize} images`);
        }
    }
    /**
     * Gets current cache statistics for monitoring and debugging.
     *
     * @returns Current cache statistics including hit rate
     *
     * @example
     * ```typescript
     * const stats = cache.getStats();
     * console.log(`Cache hit rate: ${stats.hitRate.toFixed(2)}%`);
     * console.log(`Cache size: ${stats.size}/${cache.maxCacheSize}`);
     * ```
     */
    getStats() {
        const totalRequests = this.stats.hits + this.stats.misses;
        const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests) * 100 : 0;
        return {
            ...this.stats,
            hitRate
        };
    }
    /**
     * Gets detailed information about cached images.
     *
     * @returns Array of cache entry information
     *
     * @example
     * ```typescript
     * const entries = cache.getCacheEntries();
     * entries.forEach(entry => {
     *   console.log(`${entry.source}: accessed ${entry.accessCount} times`);
     * });
     * ```
     */
    getCacheEntries() {
        const now = Date.now();
        return Array.from(this.cache.values()).map(entry => ({
            source: entry.source,
            loadedAt: entry.loadedAt,
            lastAccessed: entry.lastAccessed,
            accessCount: entry.accessCount,
            age: now - entry.loadedAt
        }));
    }
}
exports.ImageCache = ImageCache;
