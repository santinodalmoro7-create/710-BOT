"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanvasPool = void 0;
const skia_canvas_1 = require("skia-canvas");
const errors_1 = require("../errors");
/**
 * Canvas Pool implementation for reusing skia-canvas Canvas instances.
 *
 * This pool manages reusable Canvas instances to reduce memory allocation overhead
 * and improve performance in CAPTCHA generation. Uses LRU eviction strategy when
 * the pool reaches capacity.
 *
 * @example Basic usage
 * ```typescript
 * const pool = new CanvasPool({ maxPoolSize: 10 });
 *
 * const canvas = pool.acquire(300, 100);
 * // Use canvas for drawing operations
 * pool.release(canvas);
 * ```
 *
 * @example With custom configuration
 * ```typescript
 * const pool = new CanvasPool({
 *   maxPoolSize: 20,
 *   initialPoolSize: 5,
 *   debug: true
 * });
 * ```
 */
class CanvasPool {
    /**
     * Creates a new Canvas Pool instance.
     *
     * @param config - Pool configuration options
     */
    constructor(config = {}) {
        var _a, _b, _c;
        this.pool = [];
        this.maxPoolSize = (_a = config.maxPoolSize) !== null && _a !== void 0 ? _a : 10;
        this.debug = (_b = config.debug) !== null && _b !== void 0 ? _b : false;
        this.metrics = {
            available: 0,
            inUse: 0,
            totalCreated: 0,
            totalAcquires: 0,
            totalReleases: 0,
            poolMisses: 0,
            evictions: 0
        };
        // Pre-create initial canvas instances if specified
        const initialSize = (_c = config.initialPoolSize) !== null && _c !== void 0 ? _c : 0;
        if (initialSize > 0) {
            this.preCreateCanvases(Math.min(initialSize, this.maxPoolSize));
        }
        if (this.debug) {
            console.log(`CanvasPool initialized: maxSize=${this.maxPoolSize}, initialSize=${initialSize}`);
        }
    }
    /**
     * Pre-creates canvas instances for the pool.
     *
     * @param count - Number of canvas instances to create
     */
    preCreateCanvases(count) {
        for (let i = 0; i < count; i++) {
            try {
                // Create with default dimensions - will be resized when acquired
                const canvas = this.createCanvas(300, 100);
                this.pool.push({
                    canvas,
                    width: 300,
                    height: 100,
                    lastUsed: Date.now(),
                    inUse: false
                });
                this.metrics.available++;
                this.metrics.totalCreated++;
            }
            catch (error) {
                if (this.debug) {
                    console.warn(`Failed to pre-create canvas ${i + 1}:`, error);
                }
                break; // Stop pre-creation if we encounter errors
            }
        }
    }
    /**
     * Creates a new Canvas instance with error handling.
     *
     * @param width - Canvas width in pixels
     * @param height - Canvas height in pixels
     * @returns New Canvas instance
     */
    createCanvas(width, height) {
        try {
            const canvas = new skia_canvas_1.Canvas(width, height);
            canvas.gpu = false; // Ensure consistent behavior
            return canvas;
        }
        catch (error) {
            throw new errors_1.CaptchaGenerationError(`Failed to create canvas: ${(error === null || error === void 0 ? void 0 : error.message) || 'unknown error'}`, {
                param: 'canvas_creation',
                expected: `Canvas(${width}x${height})`,
                actual: (error === null || error === void 0 ? void 0 : error.name) || 'CanvasError',
                suggestion: 'Verify skia-canvas is installed correctly and dimensions are valid'
            });
        }
    }
    /**
     * Resets canvas state to prepare it for reuse.
     *
     * @param canvas - Canvas to reset
     * @param width - Target width
     * @param height - Target height
     */
    resetCanvas(canvas, width, height) {
        // Resize canvas if dimensions don't match
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
        }
        // Reset the 2D context to default state
        const ctx = canvas.getContext('2d');
        // Clear the canvas
        ctx.clearRect(0, 0, width, height);
        // Reset transformation matrix
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        // Reset drawing state to defaults
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = '#000000';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
        ctx.miterLimit = 10;
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'rgba(0, 0, 0, 0)';
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        // Set CAPTCHA-specific defaults
        ctx.lineJoin = 'miter';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
    }
    /**
     * Acquires a canvas from the pool or creates a new one.
     *
     * @param width - Required canvas width in pixels
     * @param height - Required canvas height in pixels
     * @returns Canvas instance ready for use
     *
     * @example
     * ```typescript
     * const canvas = pool.acquire(400, 150);
     * const ctx = canvas.getContext('2d');
     * // Draw on canvas...
     * pool.release(canvas);
     * ```
     */
    acquire(width, height) {
        this.metrics.totalAcquires++;
        // Look for an available canvas in the pool
        const availableIndex = this.pool.findIndex(item => !item.inUse);
        if (availableIndex !== -1) {
            // Reuse existing canvas
            const pooledCanvas = this.pool[availableIndex];
            pooledCanvas.inUse = true;
            pooledCanvas.lastUsed = Date.now();
            pooledCanvas.width = width;
            pooledCanvas.height = height;
            this.metrics.available--;
            this.metrics.inUse++;
            // Reset canvas state for reuse
            this.resetCanvas(pooledCanvas.canvas, width, height);
            if (this.debug) {
                console.log(`Canvas acquired from pool: ${width}x${height} (available: ${this.metrics.available})`);
            }
            return pooledCanvas.canvas;
        }
        // No available canvas in pool - create new one
        this.metrics.poolMisses++;
        const canvas = this.createCanvas(width, height);
        this.metrics.totalCreated++;
        // Set CAPTCHA-specific defaults
        const ctx = canvas.getContext('2d');
        ctx.lineJoin = 'miter';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        // Add to pool if there's space
        if (this.pool.length < this.maxPoolSize) {
            this.pool.push({
                canvas,
                width,
                height,
                lastUsed: Date.now(),
                inUse: true
            });
            this.metrics.inUse++;
        }
        else {
            // Pool is full - this canvas won't be pooled
            if (this.debug) {
                console.log(`Canvas created but not pooled (pool full): ${width}x${height}`);
            }
        }
        if (this.debug) {
            console.log(`New canvas created: ${width}x${height} (pool misses: ${this.metrics.poolMisses})`);
        }
        return canvas;
    }
    /**
     * Releases a canvas back to the pool for reuse.
     *
     * @param canvas - Canvas to release
     *
     * @example
     * ```typescript
     * const canvas = pool.acquire(300, 100);
     * // Use canvas...
     * pool.release(canvas);
     * ```
     */
    release(canvas) {
        this.metrics.totalReleases++;
        // Find the canvas in the pool
        const pooledIndex = this.pool.findIndex(item => item.canvas === canvas);
        if (pooledIndex !== -1) {
            const pooledCanvas = this.pool[pooledIndex];
            if (pooledCanvas.inUse) {
                pooledCanvas.inUse = false;
                pooledCanvas.lastUsed = Date.now();
                this.metrics.inUse--;
                this.metrics.available++;
                if (this.debug) {
                    console.log(`Canvas released to pool (available: ${this.metrics.available})`);
                }
                // Perform LRU eviction if pool is over capacity
                this.evictIfNeeded();
            }
        }
        else {
            // Canvas not in pool (was created when pool was full)
            if (this.debug) {
                console.log('Canvas released but was not pooled');
            }
        }
    }
    /**
     * Performs LRU eviction if the pool exceeds capacity.
     */
    evictIfNeeded() {
        const availableCanvases = this.pool.filter(item => !item.inUse);
        if (availableCanvases.length > this.maxPoolSize) {
            // Sort by last used time (oldest first)
            availableCanvases.sort((a, b) => a.lastUsed - b.lastUsed);
            // Remove oldest canvases
            const toEvict = availableCanvases.length - this.maxPoolSize;
            for (let i = 0; i < toEvict; i++) {
                const canvasToEvict = availableCanvases[i];
                const index = this.pool.indexOf(canvasToEvict);
                if (index !== -1) {
                    this.pool.splice(index, 1);
                    this.metrics.available--;
                    this.metrics.evictions++;
                    if (this.debug) {
                        console.log(`Evicted canvas from pool (evictions: ${this.metrics.evictions})`);
                    }
                }
            }
        }
    }
    /**
     * Clears all available canvases from the pool.
     * In-use canvases are not affected.
     */
    clear() {
        const initialAvailable = this.metrics.available;
        // Remove only available (not in-use) canvases
        this.pool = this.pool.filter(item => item.inUse);
        // Update metrics
        this.metrics.available = 0;
        // inUse count remains the same
        if (this.debug) {
            console.log(`Pool cleared: removed ${initialAvailable} available canvases`);
        }
    }
    /**
     * Disposes of all canvases and clears the pool completely.
     * This should be called when shutting down the application.
     */
    dispose() {
        const totalCanvases = this.pool.length;
        // Clear the pool completely
        this.pool = [];
        // Reset metrics
        this.metrics.available = 0;
        this.metrics.inUse = 0;
        if (this.debug) {
            console.log(`Pool disposed: removed ${totalCanvases} canvases`);
        }
    }
    /**
     * Gets current pool metrics for monitoring and debugging.
     *
     * @returns Current pool metrics including usage statistics
     *
     * @example
     * ```typescript
     * const metrics = pool.getMetrics();
     * console.log(`Pool usage: ${metrics.inUse}/${metrics.available + metrics.inUse}`);
     * console.log(`Cache hit rate: ${(metrics.totalAcquires - metrics.poolMisses) / metrics.totalAcquires * 100}%`);
     * ```
     */
    getMetrics() {
        return { ...this.metrics };
    }
}
exports.CanvasPool = CanvasPool;
