import { Image } from "skia-canvas";
/**
 * Configuration interface for Image Cache settings.
 */
export interface ImageCacheConfig {
    /** Maximum number of images to keep in cache */
    maxCacheSize?: number;
    /** Time-to-live for cached images in milliseconds */
    cacheTTL?: number;
    /** Enable debug logging for cache operations */
    debug?: boolean;
}
/**
 * Statistics interface for Image Cache performance monitoring.
 */
export interface ImageCacheStats {
    /** Current number of cached images */
    size: number;
    /** Total number of cache hits */
    hits: number;
    /** Total number of cache misses */
    misses: number;
    /** Total number of images loaded */
    totalLoaded: number;
    /** Number of images evicted due to TTL expiration */
    ttlEvictions: number;
    /** Number of images evicted due to cache size limits */
    sizeEvictions: number;
    /** Cache hit rate as a percentage */
    hitRate: number;
}
/**
 * Image Cache implementation for caching loaded skia-canvas Image objects.
 *
 * This cache stores loaded Image objects with path/URL as keys to eliminate
 * redundant I/O operations when the same background images are used repeatedly.
 * Uses LRU eviction with configurable size limits and TTL (time-to-live).
 *
 * @example Basic usage
 * ```typescript
 * const cache = new ImageCache({ maxCacheSize: 50, cacheTTL: 3600000 });
 *
 * // First load - cache miss, loads from disk/URL
 * const image1 = await cache.get('./background.jpg');
 *
 * // Second load - cache hit, returns cached image
 * const image2 = await cache.get('./background.jpg');
 * ```
 *
 * @example With custom configuration
 * ```typescript
 * const cache = new ImageCache({
 *   maxCacheSize: 100,
 *   cacheTTL: 1800000, // 30 minutes
 *   debug: true
 * });
 * ```
 */
export declare class ImageCache {
    private cache;
    private readonly maxCacheSize;
    private readonly cacheTTL;
    private readonly debug;
    private stats;
    /**
     * Creates a new Image Cache instance.
     *
     * @param config - Cache configuration options
     */
    constructor(config?: ImageCacheConfig);
    /**
     * Normalizes cache keys for consistent lookup.
     *
     * @param source - Image source (path, URL, or Buffer)
     * @returns Normalized cache key
     */
    private normalizeKey;
    /**
     * Checks if a cache entry has expired based on TTL.
     *
     * @param entry - Cache entry to check
     * @returns True if entry has expired
     */
    private isExpired;
    /**
     * Removes expired entries from the cache.
     */
    private cleanupExpired;
    /**
     * Performs LRU eviction if cache exceeds size limit.
     */
    private evictLRU;
    /**
     * Loads an image from the specified source.
     *
     * @param source - Image source (file path, URL, or Buffer)
     * @returns Promise that resolves to loaded Image object
     */
    private loadImageFromSource;
    /**
     * Gets an image from cache or loads it if not cached.
     *
     * @param source - Image source as file path, URL, or Buffer
     * @returns Promise that resolves to the Image object
     *
     * @example Loading from file path
     * ```typescript
     * const image = await cache.get('./assets/background.jpg');
     * ```
     *
     * @example Loading from URL
     * ```typescript
     * const image = await cache.get('https://example.com/background.png');
     * ```
     *
     * @example Loading from Buffer
     * ```typescript
     * const imageBuffer = fs.readFileSync('./background.jpg');
     * const image = await cache.get(imageBuffer);
     * ```
     */
    get(source: string | Buffer): Promise<Image>;
    /**
     * Stores an image in the cache.
     *
     * @param key - Cache key (normalized)
     * @param image - Image object to cache
     * @param originalSource - Original source for debugging
     */
    private set;
    /**
     * Manually sets an image in the cache.
     *
     * @param source - Image source identifier
     * @param image - Pre-loaded Image object
     *
     * @example Pre-loading images
     * ```typescript
     * const image = await loadImage('./background.jpg');
     * cache.setImage('./background.jpg', image);
     * ```
     */
    setImage(source: string | Buffer, image: Image): void;
    /**
     * Checks if an image is cached and not expired.
     *
     * @param source - Image source to check
     * @returns True if image is cached and valid
     *
     * @example
     * ```typescript
     * if (cache.has('./background.jpg')) {
     *   console.log('Image is cached');
     * }
     * ```
     */
    has(source: string | Buffer): boolean;
    /**
     * Removes an image from the cache.
     *
     * @param source - Image source to remove
     * @returns True if image was removed, false if not found
     *
     * @example
     * ```typescript
     * const removed = cache.delete('./old-background.jpg');
     * console.log(removed ? 'Removed' : 'Not found');
     * ```
     */
    delete(source: string | Buffer): boolean;
    /**
     * Clears all cached images.
     *
     * @example
     * ```typescript
     * cache.clear();
     * console.log('Cache cleared');
     * ```
     */
    clear(): void;
    /**
     * Gets current cache statistics for monitoring and debugging.
     *
     * @returns Current cache statistics including hit rate
     *
     * @example
     * ```typescript
     * const stats = cache.getStats();
     * console.log(`Cache hit rate: ${stats.hitRate.toFixed(2)}%`);
     * console.log(`Cache size: ${stats.size}/${cache.maxCacheSize}`);
     * ```
     */
    getStats(): ImageCacheStats;
    /**
     * Gets detailed information about cached images.
     *
     * @returns Array of cache entry information
     *
     * @example
     * ```typescript
     * const entries = cache.getCacheEntries();
     * entries.forEach(entry => {
     *   console.log(`${entry.source}: accessed ${entry.accessCount} times`);
     * });
     * ```
     */
    getCacheEntries(): Array<{
        source: string;
        loadedAt: number;
        lastAccessed: number;
        accessCount: number;
        age: number;
    }>;
}
