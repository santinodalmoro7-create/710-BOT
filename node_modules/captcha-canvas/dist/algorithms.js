"use strict";
/**
 * Optimized algorithms for CAPTCHA generation with enhanced performance.
 *
 * This module provides high-performance implementations of core CAPTCHA algorithms
 * including decoy generation, coordinate calculation, canvas operation batching,
 * and memory-efficient data structures.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.algorithmConfigManager = exports.AlgorithmConfigManager = exports.AlgorithmMemoryPool = exports.CanvasOperationBatcher = exports.OptimizedCoordinateCalculator = exports.OptimizedDecoyGenerator = exports.CoordinateCache = void 0;
const util_1 = require("./util");
const constants_1 = require("./constants");
/**
 * Coordinate cache for reusable coordinate sets.
 */
class CoordinateCache {
    constructor() {
        this.cache = new Map();
        this.accessOrder = [];
    }
    /**
     * Generates a cache key for coordinate parameters.
     */
    generateKey(width, height, size, pattern) {
        return `${width}x${height}x${size}x${pattern}`;
    }
    /**
     * Retrieves cached coordinates or generates new ones.
     */
    get(width, height, size, pattern) {
        const key = this.generateKey(width, height, size, pattern);
        if (this.cache.has(key)) {
            // Move to end of access order (most recently used)
            const index = this.accessOrder.indexOf(key);
            if (index > -1) {
                this.accessOrder.splice(index, 1);
            }
            this.accessOrder.push(key);
            return this.cache.get(key);
        }
        // Generate new coordinates
        const coordinates = this.generateCoordinates(width, height, size, pattern);
        // Cache the coordinates
        this.set(key, coordinates);
        return coordinates;
    }
    /**
     * Stores coordinates in cache with LRU eviction.
     */
    set(key, coordinates) {
        if (this.cache.size >= constants_1.MAX_COORDINATE_CACHE_SIZE) {
            // Remove least recently used
            const lruKey = this.accessOrder.shift();
            if (lruKey) {
                this.cache.delete(lruKey);
            }
        }
        this.cache.set(key, coordinates);
        this.accessOrder.push(key);
    }
    /**
     * Generates coordinates based on distribution pattern.
     */
    generateCoordinates(width, height, size, pattern) {
        const coordinates = [];
        switch (pattern) {
            case constants_1.DistributionPattern.UNIFORM:
                return (0, util_1.getRandomCoordinate)(height, width, size);
            case constants_1.DistributionPattern.RANDOM:
                for (let i = 0; i < size; i++) {
                    const x = (0, util_1.getRandom)(30, width - 30);
                    const y = (0, util_1.getRandom)(30, height - 30);
                    coordinates.push([x, y]);
                }
                return coordinates;
            case constants_1.DistributionPattern.CLUSTERED:
                // Create clusters of characters
                const numClusters = Math.max(1, Math.floor(size / 3));
                const clusterCenters = [];
                // Generate cluster centers
                for (let i = 0; i < numClusters; i++) {
                    clusterCenters.push([
                        (0, util_1.getRandom)(50, width - 50),
                        (0, util_1.getRandom)(50, height - 50)
                    ]);
                }
                // Distribute characters around cluster centers
                for (let i = 0; i < size; i++) {
                    const clusterIndex = i % numClusters;
                    const center = clusterCenters[clusterIndex];
                    const radius = 30;
                    const x = center[0] + (0, util_1.getRandom)(-radius, radius);
                    const y = center[1] + (0, util_1.getRandom)(-radius, radius);
                    coordinates.push([x, y]);
                }
                return coordinates;
            case constants_1.DistributionPattern.GRID:
                // Create a grid layout
                const cols = Math.ceil(Math.sqrt(size));
                const rows = Math.ceil(size / cols);
                const cellWidth = (width - 60) / cols;
                const cellHeight = (height - 60) / rows;
                for (let i = 0; i < size; i++) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = 30 + (col * cellWidth) + (cellWidth / 2) + (0, util_1.getRandom)(-10, 10);
                    const y = 30 + (row * cellHeight) + (cellHeight / 2) + (0, util_1.getRandom)(-10, 10);
                    coordinates.push([x, y]);
                }
                return coordinates;
            default:
                return (0, util_1.getRandomCoordinate)(height, width, size);
        }
    }
    /**
     * Clears the coordinate cache.
     */
    clear() {
        this.cache.clear();
        this.accessOrder.length = 0;
    }
    /**
     * Gets cache statistics.
     */
    getStats() {
        return {
            size: this.cache.size,
            hitRate: 0, // Would need hit/miss counters for accurate rate
            maxSize: constants_1.MAX_COORDINATE_CACHE_SIZE
        };
    }
}
exports.CoordinateCache = CoordinateCache;
// Global coordinate cache instance
let globalCoordinateCache = null;
/**
 * Gets or creates the global coordinate cache instance.
 */
function getGlobalCoordinateCache() {
    if (!globalCoordinateCache) {
        globalCoordinateCache = new CoordinateCache();
    }
    return globalCoordinateCache;
}
/**
 * Optimized decoy generation with configurable strategies.
 */
class OptimizedDecoyGenerator {
    constructor(config = constants_1.defaultDecoyConfig) {
        this.config = { ...constants_1.defaultDecoyConfig, ...config };
    }
    /**
     * Calculates optimal number of decoy characters based on strategy.
     */
    calculateDecoyCount(width, height, textLength, fontSize) {
        const canvasArea = width * height;
        switch (this.config.strategy) {
            case constants_1.DecoyStrategy.FIXED:
                return (this.config.fixedPerCharacter || 5) * textLength;
            case constants_1.DecoyStrategy.DENSITY:
                const densityFactor = this.config.densityFactor || constants_1.DECOY_BASE_DENSITY;
                const baseCount = Math.floor(canvasArea / densityFactor);
                // Adjust based on font size (smaller fonts need fewer decoys)
                const sizeAdjustment = Math.max(0.5, fontSize / 40);
                return Math.floor(baseCount * sizeAdjustment);
            case constants_1.DecoyStrategy.ADAPTIVE:
                const complexityScore = this.calculateComplexityScore(width, height, textLength, fontSize);
                const threshold = this.config.complexityThreshold || 0.7;
                if (complexityScore > threshold) {
                    // High complexity - more decoys needed
                    return Math.floor(canvasArea / (constants_1.DECOY_BASE_DENSITY * 0.8));
                }
                else {
                    // Low complexity - fewer decoys sufficient
                    return Math.floor(canvasArea / (constants_1.DECOY_BASE_DENSITY * 1.2));
                }
            default:
                return Math.floor(canvasArea / constants_1.DECOY_BASE_DENSITY);
        }
    }
    /**
     * Calculates canvas complexity score for adaptive strategy.
     */
    calculateComplexityScore(width, height, textLength, fontSize) {
        // Complexity based on text density and size variation
        const textDensity = textLength / (width * height / 10000);
        const sizeFactor = fontSize / 40; // Normalized to default size
        // Higher density and smaller text = higher complexity
        return Math.min(1.0, (textDensity * 0.6) + ((1 - sizeFactor) * 0.4));
    }
    /**
     * Generates intelligent decoy positions with spacing optimization.
     */
    generateDecoyPositions(count, width, height, existingPositions = []) {
        const positions = [];
        const maxAttempts = count * 3; // Limit attempts to prevent infinite loops
        let attempts = 0;
        for (let i = 0; i < count && attempts < maxAttempts; i++) {
            let position;
            let isValid = false;
            // Try to find a valid position
            for (let attempt = 0; attempt < 10 && !isValid; attempt++) {
                position = [
                    (0, util_1.getRandom)(20, width - 20),
                    (0, util_1.getRandom)(20, height - 20)
                ];
                isValid = this.isValidDecoyPosition(position, positions, existingPositions);
                attempts++;
            }
            if (isValid) {
                positions.push(position);
            }
        }
        return positions;
    }
    /**
     * Checks if a decoy position is valid (no excessive overlap).
     */
    isValidDecoyPosition(position, existingDecoys, existingText, minDistance = 15) {
        if (!this.config.enableIntelligentSpacing) {
            return true; // Skip validation if intelligent spacing is disabled
        }
        // Check distance from other decoys
        for (const decoy of existingDecoys) {
            const distance = Math.sqrt(Math.pow(position[0] - decoy[0], 2) +
                Math.pow(position[1] - decoy[1], 2));
            if (distance < minDistance) {
                return false;
            }
        }
        // Check distance from text characters (maintain larger distance)
        for (const text of existingText) {
            const distance = Math.sqrt(Math.pow(position[0] - text[0], 2) +
                Math.pow(position[1] - text[1], 2));
            if (distance < minDistance * 1.5) {
                return false;
            }
        }
        return true;
    }
    /**
     * Updates decoy configuration.
     */
    updateConfig(config) {
        this.config = { ...this.config, ...config };
    }
}
exports.OptimizedDecoyGenerator = OptimizedDecoyGenerator;
/**
 * Optimized coordinate calculation with caching and distribution patterns.
 */
class OptimizedCoordinateCalculator {
    constructor(config = constants_1.defaultCoordinateConfig) {
        this.config = { ...constants_1.defaultCoordinateConfig, ...config };
        this.cache = getGlobalCoordinateCache();
    }
    /**
     * Calculates optimized coordinates with caching support.
     */
    calculateCoordinates(width, height, size) {
        if (this.config.enableCaching) {
            return this.cache.get(width, height, size, this.config.pattern);
        }
        // Generate fresh coordinates without caching
        return this.generateCoordinates(width, height, size, this.config.pattern);
    }
    /**
     * Generates coordinates based on distribution pattern (no caching).
     */
    generateCoordinates(width, height, size, pattern) {
        switch (pattern) {
            case constants_1.DistributionPattern.UNIFORM:
                return (0, util_1.getRandomCoordinate)(height, width, size);
            case constants_1.DistributionPattern.RANDOM:
                const coordinates = [];
                for (let i = 0; i < size; i++) {
                    coordinates.push([
                        (0, util_1.getRandom)(30, width - 30),
                        (0, util_1.getRandom)(30, height - 30)
                    ]);
                }
                return coordinates;
            case constants_1.DistributionPattern.CLUSTERED:
                return this.generateClusteredCoordinates(width, height, size);
            case constants_1.DistributionPattern.GRID:
                return this.generateGridCoordinates(width, height, size);
            default:
                return (0, util_1.getRandomCoordinate)(height, width, size);
        }
    }
    /**
     * Generates clustered coordinate distribution.
     */
    generateClusteredCoordinates(width, height, size) {
        const coordinates = [];
        const numClusters = Math.max(1, Math.floor(size / 3));
        const clusterCenters = [];
        // Generate cluster centers
        for (let i = 0; i < numClusters; i++) {
            clusterCenters.push([
                (0, util_1.getRandom)(50, width - 50),
                (0, util_1.getRandom)(50, height - 50)
            ]);
        }
        // Distribute characters around cluster centers
        for (let i = 0; i < size; i++) {
            const clusterIndex = i % numClusters;
            const center = clusterCenters[clusterIndex];
            const radius = 30;
            coordinates.push([
                center[0] + (0, util_1.getRandom)(-radius, radius),
                center[1] + (0, util_1.getRandom)(-radius, radius)
            ]);
        }
        return coordinates;
    }
    /**
     * Generates grid-based coordinate distribution.
     */
    generateGridCoordinates(width, height, size) {
        const coordinates = [];
        const cols = Math.ceil(Math.sqrt(size));
        const rows = Math.ceil(size / cols);
        const cellWidth = (width - 60) / cols;
        const cellHeight = (height - 60) / rows;
        for (let i = 0; i < size; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            coordinates.push([
                30 + (col * cellWidth) + (cellWidth / 2) + (0, util_1.getRandom)(-10, 10),
                30 + (row * cellHeight) + (cellHeight / 2) + (0, util_1.getRandom)(-10, 10)
            ]);
        }
        return coordinates;
    }
    /**
     * Updates coordinate configuration.
     */
    updateConfig(config) {
        this.config = { ...this.config, ...config };
    }
    /**
     * Clears the coordinate cache.
     */
    clearCache() {
        this.cache.clear();
    }
}
exports.OptimizedCoordinateCalculator = OptimizedCoordinateCalculator;
/**
 * Canvas operation batcher for optimized rendering.
 */
class CanvasOperationBatcher {
    constructor(config = constants_1.defaultCanvasOperationConfig) {
        this.operations = [];
        this.profilingData = null;
        this.config = { ...constants_1.defaultCanvasOperationConfig, ...config };
        if (this.config.enableProfiling) {
            this.profilingData = {
                totalOperations: 0,
                batchedOperations: 0,
                stateChanges: 0,
                renderTime: 0
            };
        }
    }
    /**
     * Adds an operation to the batch.
     */
    addOperation(operation) {
        this.operations.push(operation);
        if (this.profilingData) {
            this.profilingData.totalOperations++;
        }
        // Auto-flush if batch size reached
        if (this.operations.length >= (this.config.batchSize || constants_1.CANVAS_OPERATION_BATCH_SIZE)) {
            this.flush();
        }
    }
    /**
     * Executes all batched operations on the canvas context.
     */
    flush() {
        if (this.operations.length === 0)
            return;
        if (this.config.enableProfiling && this.profilingData) {
            const startTime = performance.now();
            this.executeOperations();
            this.profilingData.renderTime += performance.now() - startTime;
        }
        else {
            this.executeOperations();
        }
        this.operations.length = 0; // Clear operations array
    }
    /**
     * Executes operations with optional batching optimization.
     */
    executeOperations() {
        if (!this.config.groupByStyle) {
            // Execute operations as-is
            for (const operation of this.operations) {
                this.executeSingleOperation(operation);
            }
            return;
        }
        // Group operations by style properties for better performance
        const styleGroups = new Map();
        for (const operation of this.operations) {
            const styleKey = this.getStyleKey(operation);
            if (!styleGroups.has(styleKey)) {
                styleGroups.set(styleKey, []);
            }
            styleGroups.get(styleKey).push(operation);
        }
        // Execute grouped operations
        for (const [styleKey, operations] of styleGroups) {
            this.applyStyle(styleKey);
            for (const operation of operations) {
                this.executeOperationWithoutStyle(operation);
            }
        }
    }
    /**
     * Generates a style key for grouping operations.
     */
    getStyleKey(operation) {
        return `${operation.font || ''}|${operation.fillStyle || ''}|${operation.globalAlpha || 1}`;
    }
    /**
     * Applies style properties to canvas context.
     */
    applyStyle(styleKey) {
        const [font, fillStyle, globalAlpha] = styleKey.split('|');
        // Note: This would need access to the actual canvas context
        // Implementation would be provided when integrating with Captcha class
    }
    /**
     * Executes a single operation.
     */
    executeSingleOperation(operation) {
        // Implementation would execute the specific canvas operation
        // This is a placeholder for the actual implementation
    }
    /**
     * Executes operation without applying style (for grouped operations).
     */
    executeOperationWithoutStyle(operation) {
        // Implementation would execute operation assuming style is already set
        // This is a placeholder for the actual implementation
    }
    /**
     * Gets profiling data if enabled.
     */
    getProfilingData() {
        return this.profilingData;
    }
    /**
     * Updates batcher configuration.
     */
    updateConfig(config) {
        this.config = { ...this.config, ...config };
    }
}
exports.CanvasOperationBatcher = CanvasOperationBatcher;
/**
 * Memory-efficient object pooling for algorithm calculations.
 */
class AlgorithmMemoryPool {
    constructor(createFn, resetFn, maxSize = constants_1.ALGORITHM_MEMORY_POOL_SIZE) {
        this.pool = [];
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.maxSize = maxSize;
    }
    /**
     * Acquires an object from the pool or creates a new one.
     */
    acquire() {
        const obj = this.pool.pop();
        if (obj !== undefined) {
            if (this.resetFn) {
                this.resetFn(obj);
            }
            return obj;
        }
        return this.createFn();
    }
    /**
     * Returns an object to the pool for reuse.
     */
    release(obj) {
        if (this.pool.length < this.maxSize) {
            this.pool.push(obj);
        }
    }
    /**
     * Gets pool statistics.
     */
    getStats() {
        return {
            available: this.pool.length,
            maxSize: this.maxSize,
            utilization: (this.maxSize - this.pool.length) / this.maxSize
        };
    }
    /**
     * Clears the pool.
     */
    clear() {
        this.pool.length = 0;
    }
}
exports.AlgorithmMemoryPool = AlgorithmMemoryPool;
/**
 * Global algorithm configuration manager.
 */
class AlgorithmConfigManager {
    constructor() {
        this.config = { ...constants_1.defaultAlgorithmConfig };
    }
    static getInstance() {
        if (!AlgorithmConfigManager.instance) {
            AlgorithmConfigManager.instance = new AlgorithmConfigManager();
        }
        return AlgorithmConfigManager.instance;
    }
    /**
     * Gets the current algorithm configuration.
     */
    getConfig() {
        return { ...this.config };
    }
    /**
     * Updates the algorithm configuration.
     */
    updateConfig(config) {
        this.config = this.mergeConfig(this.config, config);
    }
    /**
     * Merges configuration objects recursively.
     */
    mergeConfig(target, source) {
        const result = { ...target };
        for (const key in source) {
            if (source.hasOwnProperty(key)) {
                const sourceValue = source[key];
                const targetValue = target[key];
                if (sourceValue && typeof sourceValue === 'object' && !Array.isArray(sourceValue)) {
                    result[key] = this.mergeConfig(targetValue, sourceValue);
                }
                else {
                    result[key] = sourceValue;
                }
            }
        }
        return result;
    }
    /**
     * Resets configuration to defaults.
     */
    resetToDefaults() {
        this.config = { ...constants_1.defaultAlgorithmConfig };
    }
}
exports.AlgorithmConfigManager = AlgorithmConfigManager;
// Export singleton instance
exports.algorithmConfigManager = AlgorithmConfigManager.getInstance();
